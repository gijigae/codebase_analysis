{
    "highlights": "1. **Asynchronous Task**: The code defines a Celery shared task named `delete_segment_from_index_task` that is responsible for removing a segment from an index asynchronously.\n\n2. **Input Parameters**: The task accepts four input parameters: `segment_id`, `index_node_id`, `dataset_id`, and `document_id`. These parameters are used to identify the specific segment that needs to be removed from the index.\n\n3. **Database and Cache Interactions**: The task interacts with the database (using SQLAlchemy) to retrieve the dataset and document information. It also uses a Redis cache to store a key related to the indexing process.\n\n4. **Index Processor**: The task utilizes an `IndexProcessorFactory` to create an index processor based on the document's form (`dataset_document.doc_form`). The index processor is then used to clean the index by removing the specified index node.\n\n5. **Error Handling and Logging**: The task includes try-except block to handle any exceptions that may occur during the deletion process. It also uses the `logging` module to log relevant information, such as the start and end of the task, as well as any errors that may occur.\n\nIn summary, the key features of this code are the asynchronous task implementation, the input parameters, the database and cache interactions, the use of an index processor, and the error handling and logging mechanisms.",
    "overall_summary": "Sure, here's an overall summary of the codebase:\n\n1. **delete_segment_from_index_task**:\n   - This is a Celery shared task that runs asynchronously.\n   - The task is responsible for removing a segment from an index.\n   - It takes the following parameters:\n     - `segment_id`: The ID of the segment to be deleted.\n     - `index_node_id`: The ID of the index node.\n     - `dataset_id`: The ID of the dataset.\n     - `document_id`: The ID of the document.\n   - The task performs the following steps:\n     - Retrieves the dataset and document from the database.\n     - Checks the status of the document (enabled, archived, indexing status).\n     - Retrieves the index type of the document.\n     - Initializes the appropriate `IndexProcessor` based on the index type.\n     - Calls the `clean()` method of the `IndexProcessor` to remove the segment from the index.\n     - Logs the successful deletion of the segment and the latency.\n     - Deletes the cache key used for the indexing process.\n   - The task can be triggered by calling `delete_segment_from_index_task.delay(segment_id)`.\n\nThe codebase also imports several modules and classes:\n\n- `logging`: For logging messages.\n- `time`: For measuring the execution time of the task.\n- `click`: For formatting and styling log messages.\n- `celery`: For defining a Celery shared task.\n- `IndexProcessorFactory`: A factory class for creating `IndexProcessor` instances.\n- `db` and `redis_client`: Database and Redis client instances from the `extensions` module.\n- `Dataset` and `Document` models from the `models` module.\n\nThe overall purpose of this codebase is to provide a Celery task that can be used to asynchronously remove a segment from an index, with appropriate error handling and logging.",
    "pseudocode": "```\n# Define the delete_segment_from_index_task function\ndef delete_segment_from_index_task(segment_id, index_node_id, dataset_id, document_id):\n    # Log the start of the task\n    log_info(f\"Start delete segment from index: {segment_id}\")\n    \n    # Get the current time for measuring the task duration\n    start_time = get_current_time()\n    \n    # Define the indexing cache key\n    indexing_cache_key = f\"segment_{segment_id}_delete_indexing\"\n    \n    try:\n        # Fetch the dataset from the database\n        dataset = get_dataset(dataset_id)\n        \n        # If the dataset is not found, log and return\n        if not dataset:\n            log_info(f\"Segment {segment_id} has no dataset, pass.\")\n            return\n        \n        # Fetch the document from the database\n        document = get_document(document_id)\n        \n        # If the document is not found, log and return\n        if not document:\n            log_info(f\"Segment {segment_id} has no document, pass.\")\n            return\n        \n        # Check if the document is enabled, not archived, and has a completed indexing status\n        if not document.enabled or document.archived or document.indexing_status != \"completed\":\n            log_info(f\"Segment {segment_id} document status is invalid, pass.\")\n            return\n        \n        # Get the index type from the document\n        index_type = document.doc_form\n        \n        # Initialize the index processor based on the index type\n        index_processor = get_index_processor(index_type)\n        \n        # Clean the index by removing the specified index node\n        index_processor.clean(dataset, [index_node_id])\n        \n        # Log the successful deletion of the segment from the index\n        end_time = get_current_time()\n        log_info(f\"Segment deleted from index: {segment_id} latency: {end_time - start_time}\")\n    \n    except Exception:\n        # Log the exception if there is an error\n        log_exception(\"delete segment from index failed\")\n    \n    finally:\n        # Delete the indexing cache key\n        delete_redis_key(indexing_cache_key)\n```\n\nThe above pseudocode represents the high-level logic of the `delete_segment_from_index_task` function. It performs the following steps:\n\n1. Logs the start of the task with the segment ID.\n2. Gets the current time to measure the task duration.\n3. Defines the indexing cache key based on the segment ID.\n4. Tries to fetch the dataset and document from the database based on the provided IDs.\n5. If the dataset or document is not found, logs the information and returns.\n6. Checks the document's status (enabled, not archived, and indexing status is \"completed\").\n7. Gets the index type from the document.\n8. Initializes the index processor based on the index type.\n9. Cleans the index by removing the specified index node.\n10. Logs the successful deletion of the segment from the index, including the latency.\n11. Handles any exceptions that may occur during the task execution.\n12. Deletes the indexing cache key from the Redis client.\n\nThe pseudocode uses various helper functions, such as `log_info`, `get_current_time`, `get_dataset`, `get_document`, `get_index_processor`, `delete_redis_key`, and `log_exception`, which are not defined in the original code but are assumed to be available in the codebase.",
    "import_relationships": "Imports found:\nimport logging\nimport time\nimport click\nfrom celery import shared_task\nfrom core.rag.index_processor.index_processor_factory import IndexProcessorFactory\nfrom extensions.ext_database import db\nfrom extensions.ext_redis import redis_client\nfrom models.dataset import Dataset, Document"
}