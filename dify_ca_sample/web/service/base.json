{
    "highlights": "The key features of this code are:\n\n1. **API Configuration**: The code imports various configuration constants, such as `API_PREFIX`, `IS_CE_EDITION`, and `PUBLIC_API_PREFIX`, which are likely used to customize the API endpoints and behavior based on the application environment.\n\n2. **Content Types**: The code defines a `ContentType` object that specifies different content types, such as `json`, `stream`, `form`, `download`, and `upload`, which are used throughout the code.\n\n3. **Base Fetch Options**: The code defines a `baseOptions` object that sets the default options for the fetch requests, including the HTTP method, mode, credentials, and headers.\n\n4. **Callback Functions**: The code defines several callback functions, such as `IOnData`, `IOnThought`, `IOnFile`, `IOnMessageEnd`, `IOnMessageReplace`, `IOnAnnotationReply`, `IOnCompleted`, and `IOnError`, which are used to handle different types of responses from the API.\n\n5. **Utility Functions**: The code includes two utility functions: `unicodeToChar` and `format`, which are used to handle string formatting and unicode character conversion.\n\nThe main purpose of this code appears to be providing a set of reusable functions for making API requests, handling different types of responses, and managing the API configuration. The code seems to be part of a larger application that utilizes these features.",
    "overall_summary": "Based on the code provided, this codebase appears to be a utility module for making HTTP requests and handling server-sent events (SSE) in a TypeScript environment. Here's an overall summary of the key components:\n\n1. **Constants and Types**:\n   - `ContentType`: An object containing various content type strings (e.g., `json`, `stream`, `form`, `download`, `upload`) used for setting request headers.\n   - `baseOptions`: The default options object for `fetch` requests, including the mode, credentials, and headers.\n   - Various type definitions for callback functions, such as `IOnData`, `IOnThought`, `IOnFile`, etc., used for handling different events in SSE responses.\n\n2. **Utility Functions**:\n   - `unicodeToChar`: A function that converts Unicode escape sequences in a string to their corresponding characters.\n   - `format`: A function that formats a given text, trimming leading/trailing whitespaces and replacing newlines with `<br/>`.\n\n3. **SSE Handling**:\n   - `handleStream`: A function that processes the server-sent event stream, parsing the incoming data and invoking the appropriate callback functions (e.g., `onData`, `onThought`, `onFile`, etc.).\n\n4. **Base Fetch Function**:\n   - `baseFetch`: The main function that handles HTTP requests, taking a URL, fetch options, and additional options (e.g., `isPublicAPI`, `bodyStringify`, `needAllResponseContent`). It applies various transformations to the request and response, including handling query parameters, timeouts, and error cases.\n\n5. **Request Methods**:\n   - `request`, `get`, `post`, `put`, `del`, `patch`: Wrapper functions around `baseFetch` that provide a more convenient interface for making different types of HTTP requests (GET, POST, PUT, DELETE, PATCH) with optional public API support.\n\n6. **Upload Function**:\n   - `upload`: A function that handles file uploads, taking an options object, an optional boolean flag for public API, and optional URL and search parameters.\n\n7. **SSE Post Function**:\n   - `ssePost`: A function that initiates a server-sent event stream, taking a URL, fetch options, and various callback functions to handle the incoming data and events.\n\nOverall, this codebase provides a consistent and abstracted interface for making HTTP requests and handling server-sent events, with support for various content types, error handling, and public API integration.",
    "pseudocode": "```python\n# Define constants and helper functions\nCONTENT_TYPES = {\n    \"json\": \"application/json\",\n    \"stream\": \"text/event-stream\",\n    \"form\": \"application/x-www-form-urlencoded; charset=UTF-8\",\n    \"download\": \"application/octet-stream\",\n    \"upload\": \"multipart/form-data\"\n}\n\ndef unicode_to_char(text):\n    # Convert unicode escape sequences to characters\n    pass\n\ndef format_text(text):\n    # Format the text (trim, replace newlines, etc.)\n    pass\n\n# Define types for callbacks\nOnDataCallback = Callable[[str, bool, Dict[str, Any]], None]\nOnThoughtCallback = Callable[[Dict[str, Any]], None]\nOnFileCallback = Callable[[Dict[str, Any]], None]\nOnMessageEndCallback = Callable[[Dict[str, Any]], None]\nOnMessageReplaceCallback = Callable[[Dict[str, Any]], None]\nOnAnnotationReplyCallback = Callable[[Dict[str, Any]], None]\nOnCompletedCallback = Callable[[bool], None]\nOnErrorCallback = Callable[[str, Optional[str]], None]\n\n# Define base options for fetch requests\nBASE_OPTIONS = {\n    \"method\": \"GET\",\n    \"mode\": \"cors\",\n    \"credentials\": \"include\",\n    \"headers\": {\n        \"Content-Type\": CONTENT_TYPES[\"json\"]\n    },\n    \"redirect\": \"follow\"\n}\n\n# Define the main function to handle fetch requests\ndef base_fetch(url, fetch_options, other_options={}):\n    # Merge base options with fetch options\n    options = {**BASE_OPTIONS, **fetch_options}\n\n    # Handle authorization headers\n    if other_options.get(\"isPublicAPI\"):\n        # Get shared token from URL and use it for authorization\n        pass\n    else:\n        # Use console token for authorization\n        pass\n\n    # Handle content type\n    if other_options.get(\"deleteContentType\"):\n        options[\"headers\"].pop(\"Content-Type\", None)\n    else:\n        content_type = options[\"headers\"].get(\"Content-Type\")\n        if not content_type:\n            options[\"headers\"][\"Content-Type\"] = CONTENT_TYPES[\"json\"]\n\n    # Handle URL prefix based on public API flag\n    url_prefix = other_options.get(\"PUBLIC_API_PREFIX\") if other_options.get(\"isPublicAPI\") else other_options.get(\"API_PREFIX\")\n    url_with_prefix = f\"{url_prefix}{url if url.startswith('/') else '/' + url}\"\n\n    # Handle query parameters for GET requests\n    if options[\"method\"] == \"GET\" and \"params\" in options:\n        params = options.pop(\"params\")\n        query_params = [\"{}={}\".format(k, urllib.parse.quote(str(v))) for k, v in params.items()]\n        if \"?\" in url_with_prefix:\n            url_with_prefix += \"&\" + \"&\".join(query_params)\n        else:\n            url_with_prefix += \"?\" + \"&\".join(query_params)\n\n    # Handle request body\n    if \"body\" in options and other_options.get(\"bodyStringify\"):\n        options[\"body\"] = json.dumps(options[\"body\"])\n\n    # Handle timeout\n    return Promise.race([\n        # Timeout promise\n        asyncio.create_task(asyncio.sleep(OTHER_OPTIONS.get(\"TIME_OUT\", 100000))).then(\n            lambda _: raise Exception(\"request timeout\")\n        ),\n        # Fetch promise\n        asyncio.create_task(\n            fetch(url_with_prefix, options)\n            .then(handle_response)\n            .catch(handle_error)\n        )\n    ])\n\n# Handle the response from the fetch request\ndef handle_response(response):\n    if not response.ok:\n        # Handle error responses\n        return response.json().then(\n            lambda data: raise ResponseError(data.get(\"code\"), data.get(\"message\"), response.status)\n        )\n\n    # Handle successful responses\n    if response.status == 204:\n        # Handle delete API responses\n        return {\"result\": \"success\"}\n    else:\n        # Return the response data\n        content_type = response.headers.get(\"Content-Type\")\n        if content_type == CONTENT_TYPES[\"download\"]:\n            return response.blob()\n        else:\n            return response.json()\n\n# Handle errors from the fetch request\ndef handle_error(error):\n    # Display error message using Toast component\n    Toast.notify({\"type\": \"error\", \"message\": str(error)})\n    raise error\n\n# Define the main request function\ndef request(url, options={}, other_options={}):\n    return base_fetch(url, options, other_options)\n\n# Define the request method functions\ndef get(url, options={}, other_options={}):\n    return request(url, {**options, \"method\": \"GET\"}, other_options)\n\ndef post(url, options={}, other_options={}):\n    return request(url, {**options, \"method\": \"POST\"}, other_options)\n\ndef put(url, options={}, other_options={}):\n    return request(url, {**options, \"method\": \"PUT\"}, other_options)\n\ndef delete(url, options={}, other_options={}):\n    return request(url, {**options, \"method\": \"DELETE\"}, other_options)\n\ndef patch(url, options={}, other_options={}):\n    return request(url, {**options, \"method\": \"PATCH\"}, other_options)\n\n# Define the public API request functions\ndef get_public(url, options={}, other_options={}):\n    return get(url, options, {**other_options, \"isPublicAPI\": True})\n\ndef post_public(url, options={}, other_options={}):\n    return post(url, options, {**other_options, \"isPublicAPI\": True})\n\ndef put_public(url, options={}, other_options={}):\n    return put(url, options, {**other_options, \"isPublicAPI\": True})\n\ndef delete_public(url, options={}, other_options={}):\n    return delete(url, options, {**other_options, \"isPublicAPI\": True})\n\ndef patch_public(url, options={}, other_options={}):\n    return patch(url, options, {**other_options, \"isPublicAPI\": True})\n\n# Define the upload function\ndef upload(options, is_public_api=False, url=None, search_params=None):\n    # Handle authorization for public API or console\n    if is_public_api:\n        # Get shared token from URL and use it for authorization\n        pass\n    else:\n        # Use console token for authorization\n        pass\n\n    # Merge default options with the provided options\n    default_options = {\n        \"method\": \"POST\",\n        \"url\": (url if url else \"/files/upload\") + (search_params or \"\"),\n        \"headers\": {\n            \"Authorization\": f\"Bearer {token}\"\n        },\n        \"data\": {}\n    }\n    options = {**default_options, **options}\n\n    # Send the upload request using Promise\n    return Promise(\n        lambda resolve, reject: {\n            # Open the XHR request\n            xhr.open(options[\"method\"], options[\"url\"])\n            # Set the request headers\n            for key, value in options[\"headers\"].items():\n                xhr.setRequestHeader(key, value)\n            # Set other options\n            xhr.withCredentials = True\n            xhr.responseType = \"json\"\n            # Handle the response\n            xhr.onreadystatechange = lambda: {\n                if xhr.readyState == 4:\n                    if xhr.status == 201:\n                        resolve(xhr.response)\n                    else:\n                        reject(xhr)\n            }\n            # Handle progress callbacks\n            xhr.upload.onprogress = options[\"onprogress\"]\n            # Send the request\n            xhr.send(options[\"data\"])\n        }\n    )\n\n# Define the SSE (Server-Sent Events) POST function\ndef sse_post(url, fetch_options, other_options={}):\n    # Create an AbortController\n    abort_controller = AbortController()\n\n    # Merge base options with fetch options\n    options = {**BASE_OPTIONS, \"method\": \"POST\", \"signal\": abort_controller.signal, **fetch_options}\n\n    # Handle content type\n    content_type = options[\"headers\"].get(\"Content-Type\")\n    if",
    "import_relationships": "Imports found:\nimport { API_PREFIX, IS_CE_EDITION, PUBLIC_API_PREFIX } from '@/config'\nimport Toast from '@/app/components/base/toast'\nimport type { AnnotationReply, MessageEnd, MessageReplace, ThoughtItem } from '@/app/components/app/chat/type'\nimport type { VisionFile } from '@/types/app'"
}