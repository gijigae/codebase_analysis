{
    "highlights": "The key features of this code are:\n\n1. **Asynchronous Task**: The `disable_segment_from_index_task` function is defined as a Celery shared task, which allows it to be executed asynchronously in the background.\n\n2. **Database Interaction**: The code interacts with the database using the `db` object from the `extensions.ext_database` module to fetch and update the `DocumentSegment` model.\n\n3. **Error Handling**: The code handles various exceptions and errors, such as when the segment is not found or not in the completed state, and logs the errors accordingly.\n\n4. **Index Processor**: The code uses the `IndexProcessorFactory` to create an index processor based on the document's type, and then calls the `clean` method to remove the segment from the index.\n\n5. **Caching**: The code uses a Redis-based cache to store the indexing status of the segment, and deletes the cache key when the task is completed.\n\nOverall, the key feature of this code is the asynchronous task that removes a segment from the index, with robust error handling, database interactions, and caching mechanisms to ensure the task's reliability and efficiency.",
    "overall_summary": "The provided code is a Python file named `disable_segment_from_index_task.py` that contains a Celery task function called `disable_segment_from_index_task`. This task is responsible for asynchronously disabling a segment from the index.\n\nHere's a summary of the code:\n\n1. **Imports**: The file imports various modules and classes, including `logging`, `time`, `click`, `celery`, `werkzeug.exceptions`, `IndexProcessorFactory`, `db` from `extensions.ext_database`, `redis_client` from `extensions.ext_redis`, and `DocumentSegment` from `models.dataset`.\n\n2. **`disable_segment_from_index_task`**: This is the main function that runs the task. It takes a `segment_id` as input and performs the following steps:\n   - Logs the start of the task.\n   - Retrieves the `DocumentSegment` object from the database based on the `segment_id`.\n   - Checks if the segment exists and if its status is 'completed'. If not, it raises appropriate exceptions.\n   - Retrieves the dataset and document associated with the segment.\n   - Checks if the document is enabled, not archived, and has a 'completed' indexing status. If not, it logs a message and returns.\n   - Gets the index type of the document and initializes an `IndexProcessor` instance using the `IndexProcessorFactory`.\n   - Calls the `clean` method of the `IndexProcessor` to remove the segment from the index.\n   - Logs the successful completion of the task.\n   - In case of any exceptions, it logs the error, sets the segment's `enabled` flag to `True`, and commits the changes to the database.\n   - Finally, it deletes the `indexing_cache_key` from the Redis client.\n\nThe purpose of this code is to provide an asynchronous task that can be used to disable a specific segment from the index. This could be useful in scenarios where a segment needs to be removed from the index, such as when a document is updated or deleted.",
    "pseudocode": "Certainly! Here's the high-level pythonic pseudocode for the `disable_segment_from_index_task` function:\n\n```python\n# Import necessary modules and classes\nimport logging\nimport time\nimport click\nfrom celery import shared_task\nfrom werkzeug.exceptions import NotFound\nfrom core.rag.index_processor.index_processor_factory import IndexProcessorFactory\nfrom extensions.ext_database import db\nfrom extensions.ext_redis import redis_client\nfrom models.dataset import DocumentSegment\n\n# Define the async task function\n@shared_task(queue='dataset')\ndef disable_segment_from_index_task(segment_id: str):\n    \"\"\"\n    Asynchronously disable a segment from the index.\n\n    Args:\n        segment_id (str): The ID of the segment to be disabled.\n    \"\"\"\n    # Log the start of the task\n    logging.info(click.style(f'Start disable segment from index: {segment_id}', fg='green'))\n    start_at = time.perf_counter()\n\n    # Fetch the segment from the database\n    segment = db.session.query(DocumentSegment).filter(DocumentSegment.id == segment_id).first()\n    if not segment:\n        # Raise an exception if the segment is not found\n        raise NotFound('Segment not found')\n\n    # Check if the segment is in the 'completed' status\n    if segment.status != 'completed':\n        # Raise an exception if the segment is not completed\n        raise NotFound('Segment is not completed, disable action is not allowed.')\n\n    # Generate the cache key for the segment's indexing status\n    indexing_cache_key = f'segment_{segment.id}_indexing'\n\n    try:\n        # Fetch the dataset and document associated with the segment\n        dataset = segment.dataset\n        if not dataset:\n            # Log and skip if the segment has no dataset\n            logging.info(click.style(f'Segment {segment.id} has no dataset, pass.', fg='cyan'))\n            return\n\n        dataset_document = segment.document\n        if not dataset_document:\n            # Log and skip if the segment has no document\n            logging.info(click.style(f'Segment {segment.id} has no document, pass.', fg='cyan'))\n            return\n\n        # Check if the document is in a valid state for disabling the segment\n        if not dataset_document.enabled or dataset_document.archived or dataset_document.indexing_status != 'completed':\n            # Log and skip if the document is in an invalid state\n            logging.info(click.style(f'Segment {segment.id} document status is invalid, pass.', fg='cyan'))\n            return\n\n        # Fetch the index type and initialize the index processor\n        index_type = dataset_document.doc_form\n        index_processor = IndexProcessorFactory(index_type).init_index_processor()\n\n        # Clean the index by removing the segment\n        index_processor.clean(dataset, [segment.index_node_id])\n\n        # Log the completion of the task\n        end_at = time.perf_counter()\n        logging.info(click.style(f'Segment removed from index: {segment.id} latency: {end_at - start_at}', fg='green'))\n    except Exception:\n        # Log the exception and re-enable the segment if an error occurs\n        logging.exception(\"remove segment from index failed\")\n        segment.enabled = True\n        db.session.commit()\n    finally:\n        # Delete the indexing cache key\n        redis_client.delete(indexing_cache_key)\n```\n\nIn this pseudocode, the `disable_segment_from_index_task` function is defined as a Celery shared task that runs asynchronously in the `dataset` queue. The function first fetches the segment from the database, checks its status, and then retrieves the associated dataset and document. If the document is in a valid state, the function initializes the appropriate index processor and removes the segment from the index. Finally, it logs the completion of the task and deletes the indexing cache key.\n\nThe pseudocode is written in a high-level, abstract manner, focusing on the overall flow and functionality of the task, rather than providing specific implementation details.",
    "import_relationships": "Imports found:\nimport logging\nimport time\nimport click\nfrom celery import shared_task\nfrom werkzeug.exceptions import NotFound\nfrom core.rag.index_processor.index_processor_factory import IndexProcessorFactory\nfrom extensions.ext_database import db\nfrom extensions.ext_redis import redis_client\nfrom models.dataset import DocumentSegment"
}